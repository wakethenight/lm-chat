<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multi-Provider LLM UI</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --panel2: #10131a;
      --text: #e7e9ee;
      --muted: #a7adbb;
      --border: #2a3142;
      --accent: #7d0fd6;
      --accent2: #4f7cff;
      --danger: #ff4d4d;
      --ok: #33d17a;
      --warning: #ffa500;
      --bubbleUser: #7d0fd6;
      --bubbleAI: #2a3142;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      background: var(--bg);
      color: var(--text);
      font-family: var(--sans);
      overflow: hidden;
    }

    /* Sidebar */
    #sidebar {
      width: 260px;
      background: linear-gradient(180deg, rgba(21,25,34,0.98), rgba(16,19,26,0.98));
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: transform 0.3s;
    }

    #sidebar.hidden {
      transform: translateX(-100%);
    }

    .sidebarHeader {
      padding: 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
    }

    .sidebarHeader button {
      flex: 1;
      padding: 10px;
      background: linear-gradient(135deg, rgba(125,15,214,0.95), rgba(79,124,255,0.75));
      border: 1px solid rgba(125,15,214,0.45);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    #chatList {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .chatItem {
      padding: 10px 12px;
      background: rgba(10,12,18,0.5);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      transition: all 0.2s;
    }

    .chatItem:hover {
      background: rgba(125,15,214,0.15);
      border-color: rgba(125,15,214,0.4);
    }

    .chatItem.active {
      background: rgba(125,15,214,0.25);
      border-color: rgba(125,15,214,0.6);
    }

    .chatTitle {
      flex: 1;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chatDelete {
      background: none;
      border: none;
      color: var(--danger);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 16px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .chatItem:hover .chatDelete {
      opacity: 1;
    }

    .chatDelete:hover {
      background: rgba(255,77,77,0.2);
    }

    /* Main Content */
    #mainContent {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
    }

    #toggleSidebar {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      background: rgba(21,25,34,0.95);
      border: 1px solid var(--border);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      color: var(--text);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px 12px 12px 60px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(21,25,34,0.95), rgba(16,19,26,0.95));
      backdrop-filter: blur(8px);
    }

    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }

    .labelRow {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      min-width: 0;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .hint {
      font-size: 11px;
      color: var(--muted);
      opacity: 0.9;
      font-family: var(--mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    input[type="password"], input[type="text"], select {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(10,12,18,0.75);
      color: var(--text);
      outline: none;
    }

    input[type="password"]:focus, input[type="text"]:focus, select:focus, textarea:focus {
      border-color: rgba(125,15,214,0.65);
      box-shadow: 0 0 0 3px rgba(125,15,214,0.18);
    }

    .btnRow {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--border);
      background: rgba(10,12,18,0.7);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
    }

    button.primary {
      border-color: rgba(125,15,214,0.45);
      background: linear-gradient(135deg, rgba(125,15,214,0.95), rgba(79,124,255,0.75));
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #chat {
      flex: 1;
      overflow-y: auto;
      padding: 16px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .msgWrapper {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-width: 78ch;
    }

    .msgWrapper.user {
      align-self: flex-end;
    }

    .msgWrapper.assistant {
      align-self: flex-start;
    }

    .msg {
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.06);
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
      position: relative;
    }

    .msg.user {
      background: rgba(125,15,214,0.9);
      border-color: rgba(125,15,214,0.25);
      border-bottom-right-radius: 6px;
    }

    .msg.assistant {
      background: rgba(42,49,66,0.65);
      border-color: rgba(42,49,66,0.85);
      border-bottom-left-radius: 6px;
    }

    .msg.meta {
      align-self: center;
      max-width: 100%;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      background: rgba(10,12,18,0.45);
      border-color: rgba(255,255,255,0.06);
    }

    .msg.editing {
      padding: 0;
      background: none;
      border: none;
    }

    .editTextarea {
      width: 100%;
      min-height: 100px;
      padding: 10px 12px;
      background: rgba(42,49,66,0.85);
      border: 2px solid rgba(125,15,214,0.65);
      border-radius: 14px;
      color: var(--text);
      font-family: var(--sans);
      font-size: 14px;
      line-height: 1.45;
      resize: vertical;
      outline: none;
    }

    .editActions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
    }

    .editActions button {
      padding: 6px 12px;
      font-size: 12px;
    }

    .msgActions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .msgWrapper:hover .msgActions {
      opacity: 1;
    }

    .msgWrapper.user .msgActions {
      justify-content: flex-end;
    }

    .msgAction {
      background: rgba(10,12,18,0.9);
      border: 1px solid var(--border);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      color: var(--muted);
    }

    .msgAction:hover {
      background: rgba(125,15,214,0.3);
      color: var(--text);
    }

    .composer {
      border-top: 1px solid var(--border);
      padding: 12px;
      background: linear-gradient(0deg, rgba(21,25,34,0.95), rgba(16,19,26,0.95));
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
    }

    textarea {
      width: 100%;
      min-height: 54px;
      max-height: 220px;
      resize: vertical;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(10,12,18,0.75);
      color: var(--text);
      outline: none;
      font-family: var(--sans);
    }

    .status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-top: 1px dashed rgba(255,255,255,0.08);
      background: rgba(10,12,18,0.35);
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      flex-wrap: wrap;
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pill.ok { border-color: rgba(51,209,122,0.25); color: var(--ok); }
    .pill.bad { border-color: rgba(255,77,77,0.25); color: var(--danger); }
    .pill.warn { border-color: rgba(255,165,0,0.25); color: var(--warning); }

    .costTracker {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    @media (max-width: 768px) {
      #sidebar {
        position: absolute;
        z-index: 100;
        height: 100%;
      }
      .row { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <aside id="sidebar">
    <div class="sidebarHeader">
      <button id="newChat">+ New Chat</button>
    </div>
    <div id="chatList"></div>
  </aside>

  <div id="mainContent">
    <button id="toggleSidebar">☰</button>

    <header>
      <div class="row">
        <div class="field">
          <div class="labelRow">
            <label>Provider</label>
            <span class="hint" id="providerHint"></span>
          </div>
          <select id="provider">
            <option value="openai">OpenAI</option>
            <option value="gemini">Google (Gemini)</option>
          </select>
        </div>

        <div class="field">
          <div class="labelRow">
            <label for="apiKey">API Key</label>
            <span class="hint" id="keyHint"></span>
          </div>
          <input id="apiKey" type="password" placeholder="Paste your key here..." autocomplete="off" />
        </div>

        <div class="field">
          <div class="labelRow">
            <label for="model">Model</label>
            <span class="hint" id="modelHint"></span>
          </div>
          <select id="model"></select>
        </div>

        <div class="field">
          <div class="labelRow">
            <label for="customModel">Custom model</label>
            <span class="hint">optional override</span>
          </div>
          <input id="customModel" type="text" placeholder="e.g. gpt-4.1" />
        </div>
      </div>

      <div class="btnRow">
        <button id="resetCost">Reset Cost</button>
        <button id="send" class="primary">Send</button>
      </div>
    </header>

    <main>
      <div id="chat"></div>

      <div class="composer">
        <textarea id="input" placeholder="Type here. Enter = send, Shift+Enter = newline."></textarea>
        <button id="send2" class="primary">Send</button>
      </div>

      <div class="status">
        <div class="pill" id="statusLeft">idle</div>
        <div class="costTracker">
          <div class="pill warn" id="sessionCost">Session: $0.0000</div>
          <div class="pill" id="lastCost">Last: $0.0000</div>
          <div class="pill" id="tokenCount">Tokens: 0</div>
        </div>
      </div>
    </main>
  </div>

    <script>
    const PRICING = {
      openai: {
        'gpt-4.1': { input: 15.00, output: 60.00 },
        'gpt-4.1-mini': { input: 1.50, output: 6.00 },
        'gpt-4.1-nano': { input: 0.40, output: 1.60 },
        'gpt-4o': { input: 2.50, output: 10.00 },
        'gpt-4o-mini': { input: 0.15, output: 0.60 },
        'o1': { input: 15.00, output: 60.00 },
        'o1-mini': { input: 3.00, output: 12.00 },
        'o3-mini': { input: 1.10, output: 4.40 }
      },
      gemini: {
        'gemini-3-pro-preview': [2.00, 12.00],
	'gemini-2.5-pro': [1.25, 10.00], 
	'gemini-2.5-flash': [0.30, 2.50],
        'gemini-2.0-flash-exp': [0.00, 0.00], // Free during preview
        'gemini-exp-1206': [0.00, 0.00],
        'gemini-2.0-flash-thinking-exp-1219': [0.00, 0.00],
        'gemini-1.5-pro': [1.25, 5.00],
        'gemini-1.5-flash': [0.075, 0.30],
        'gemini-1.5-flash-8b': [0.0375, 0.15]

      }
    };

    const PROVIDER_MODELS = {
      openai: ['gpt-4.1', 'gpt-4.1-mini', 'gpt-4.1-nano', 'gpt-4o', 'gpt-4o-mini', 'o1', 'o1-mini', 'o3-mini'],
      gemini: [   'gemini-3-pro-preview',
	      'gemini-2.5-pro',
	      'gemini-2.5-flash',
        'gemini-2.0-flash-exp',
        'gemini-exp-1206',
        'gemini-2.0-flash-thinking-exp-1219',
        'gemini-1.5-pro',
        'gemini-1.5-flash',
        'gemini-1.5-flash-8b']
    };

    const els = {
      sidebar: document.getElementById('sidebar'),
      toggleSidebar: document.getElementById('toggleSidebar'),
      newChat: document.getElementById('newChat'),
      chatList: document.getElementById('chatList'),
      provider: document.getElementById('provider'),
      apiKey: document.getElementById('apiKey'),
      model: document.getElementById('model'),
      customModel: document.getElementById('customModel'),
      resetCost: document.getElementById('resetCost'),
      send: document.getElementById('send'),
      send2: document.getElementById('send2'),
      input: document.getElementById('input'),
      chat: document.getElementById('chat'),
      statusLeft: document.getElementById('statusLeft'),
      keyHint: document.getElementById('keyHint'),
      modelHint: document.getElementById('modelHint'),
      providerHint: document.getElementById('providerHint'),
      sessionCost: document.getElementById('sessionCost'),
      lastCost: document.getElementById('lastCost'),
      tokenCount: document.getElementById('tokenCount')
    };

    const LS = {
      provider: 'llmui_provider',
      keys: { openai: 'llmui_openai_key', gemini: 'llmui_gemini_key' },
      model: 'llmui_model_v2',
      customModel: 'llmui_custom_model',
      chats: 'llmui_chats_v3',
      activeChat: 'llmui_active_chat',
      sessionCost: 'llmui_session_cost'
    };

    let chats = [];
    let activeChat = null;
    let sessionTotalCost = 0;
    let editingMessageIndex = null;

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    function createNewChat() {
      const chat = {
        id: generateId(),
        title: 'New Chat',
        messages: [{ role: 'system', content: 'You are a helpful assistant.' }],
        createdAt: Date.now()
      };
      chats.unshift(chat);
      saveChats();
      switchToChat(chat.id);
      renderChatList();
    }

    function deleteChat(id) {
      if (!confirm('Delete this chat?')) return;
      chats = chats.filter(c => c.id !== id);
      saveChats();
      if (activeChat?.id === id) {
        if (chats.length > 0) {
          switchToChat(chats[0].id);
        } else {
          createNewChat();
        }
      }
      renderChatList();
    }

    function switchToChat(id) {
      activeChat = chats.find(c => c.id === id);
      if (!activeChat) {
        createNewChat();
        return;
      }
      localStorage.setItem(LS.activeChat, id);
      renderChat();
      renderChatList();
    }

    function saveChats() {
      localStorage.setItem(LS.chats, JSON.stringify(chats));
    }

    function loadChats() {
      try {
        const saved = localStorage.getItem(LS.chats);
        if (saved) {
          chats = JSON.parse(saved);
        }
      } catch {}

      if (chats.length === 0) {
        createNewChat();
        return;
      }

      const lastActiveId = localStorage.getItem(LS.activeChat);
      if (lastActiveId && chats.find(c => c.id === lastActiveId)) {
        switchToChat(lastActiveId);
      } else {
        switchToChat(chats[0].id);
      }
    }

    function renderChatList() {
      els.chatList.innerHTML = '';
      for (const chat of chats) {
        const div = document.createElement('div');
        div.className = 'chatItem' + (activeChat?.id === chat.id ? ' active' : '');
        
        const title = document.createElement('div');
        title.className = 'chatTitle';
        title.textContent = chat.title;
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'chatDelete';
        deleteBtn.textContent = '×';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          deleteChat(chat.id);
        };

        div.appendChild(title);
        div.appendChild(deleteBtn);
        div.onclick = () => switchToChat(chat.id);
        
        els.chatList.appendChild(div);
      }
    }

    function updateChatTitle() {
      if (!activeChat || activeChat.messages.length < 3) return;
      const firstUser = activeChat.messages.find(m => m.role === 'user');
      if (firstUser && activeChat.title === 'New Chat') {
        activeChat.title = firstUser.content.slice(0, 30) + (firstUser.content.length > 30 ? '...' : '');
        saveChats();
        renderChatList();
      }
    }

    function renderChat() {
      els.chat.innerHTML = '';
      if (!activeChat) return;

      for (let i = 0; i < activeChat.messages.length; i++) {
        const m = activeChat.messages[i];
        if (m.role === 'system') continue;
        
        if (m.role === 'meta') {
          const div = document.createElement('div');
          div.className = 'msg meta';
          div.textContent = m.content;
          els.chat.appendChild(div);
          continue;
        }

        const wrapper = document.createElement('div');
        wrapper.className = `msgWrapper ${m.role}`;

        // Check if this message is being edited
        if (editingMessageIndex === i) {
          const editDiv = document.createElement('div');
          editDiv.className = 'msg editing';
          
          const textarea = document.createElement('textarea');
          textarea.className = 'editTextarea';
          textarea.value = m.content;
          
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'editActions';
          
          const saveBtn = document.createElement('button');
          saveBtn.textContent = 'Save';
          saveBtn.className = 'primary';
          saveBtn.onclick = () => saveEdit(i, textarea.value);
          
          const cancelBtn = document.createElement('button');
          cancelBtn.textContent = 'Cancel';
          cancelBtn.onclick = () => cancelEdit();
          
          actionsDiv.appendChild(cancelBtn);
          actionsDiv.appendChild(saveBtn);
          
          editDiv.appendChild(textarea);
          wrapper.appendChild(editDiv);
          wrapper.appendChild(actionsDiv);
          els.chat.appendChild(wrapper);
          
          // Focus the textarea
          setTimeout(() => textarea.focus(), 0);
          continue;
        }

        const msg = document.createElement('div');
        msg.className = `msg ${m.role}`;
        msg.textContent = m.content;

        const actions = document.createElement('div');
        actions.className = 'msgActions';

        const copyBtn = document.createElement('button');
        copyBtn.className = 'msgAction';
        copyBtn.textContent = 'Copy';
        copyBtn.onclick = () => {
          navigator.clipboard.writeText(m.content);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => copyBtn.textContent = 'Copy', 1000);
        };
        actions.appendChild(copyBtn);

        // Edit button for BOTH user and assistant messages
        const editBtn = document.createElement('button');
        editBtn.className = 'msgAction';
        editBtn.textContent = 'Edit';
        editBtn.onclick = () => startEdit(i);
        actions.appendChild(editBtn);

        // Regenerate button on ALL assistant messages
        if (m.role === 'assistant') {
          const regenBtn = document.createElement('button');
          regenBtn.className = 'msgAction';
          regenBtn.textContent = 'Regenerate';
          regenBtn.onclick = () => regenerateResponse(i);
          actions.appendChild(regenBtn);
        }

        const delBtn = document.createElement('button');
        delBtn.className = 'msgAction';
        delBtn.textContent = 'Delete';
        delBtn.onclick = () => deleteMessage(i);
        actions.appendChild(delBtn);

        wrapper.appendChild(msg);
        wrapper.appendChild(actions);
        els.chat.appendChild(wrapper);
      }

      els.chat.scrollTop = els.chat.scrollHeight;
    }

    function startEdit(index) {
      editingMessageIndex = index;
      renderChat();
    }

    function cancelEdit() {
      editingMessageIndex = null;
      renderChat();
    }

    function saveEdit(index, newContent) {
      if (!newContent.trim()) {
        cancelEdit();
        return;
      }

      const msg = activeChat.messages[index];
      const oldContent = msg.content;
      
      if (newContent === oldContent) {
        cancelEdit();
        return;
      }

      msg.content = newContent;
      
      // If editing a user message, remove everything after it and regenerate
      if (msg.role === 'user') {
        activeChat.messages = activeChat.messages.slice(0, index + 1);
        saveChats();
        editingMessageIndex = null;
        renderChat();
        sendMessage(newContent, true);
      } else {
        // Just save the edit for assistant messages
        saveChats();
        editingMessageIndex = null;
        renderChat();
      }
    }

    function deleteMessage(index) {
      activeChat.messages.splice(index, 1);
      saveChats();
      renderChat();
    }

    function regenerateResponse(index) {
      if (!activeChat) return;
      
      // Find the user message that prompted this response
      let userMessageIndex = -1;
      for (let i = index - 1; i >= 0; i--) {
        if (activeChat.messages[i].role === 'user') {
          userMessageIndex = i;
          break;
        }
      }
      
      if (userMessageIndex === -1) return;
      
      // Remove this assistant message and any meta message after it, plus everything after
      activeChat.messages.splice(index, activeChat.messages.length - index);
      
      saveChats();
      renderChat();
      
      // Get all messages up to and including the user message
      const messagesToSend = activeChat.messages.slice(0, userMessageIndex + 1);
      const userMessage = activeChat.messages[userMessageIndex].content;
      
      // Regenerate response
      sendMessageFromHistory(messagesToSend, userMessage);
    }

    function addMessage(role, content) {
      if (!activeChat) return;
      activeChat.messages.push({ role, content });
      saveChats();
      updateChatTitle();
      renderChat();
    }

    function maskKey(k) {
      if (!k) return '';
      if (k.length <= 10) return 'key set';
      return `${k.slice(0, 3)}…${k.slice(-4)}`;
    }

    function setStatus(left, ok = true) {
      els.statusLeft.textContent = left || '';
      els.statusLeft.className = `pill ${ok ? 'ok' : 'bad'}`;
    }

    function updateCostDisplay(lastCost = null, tokens = null) {
      const validSessionCost = isNaN(sessionTotalCost) ? 0 : sessionTotalCost;
      sessionTotalCost = validSessionCost;
      
      els.sessionCost.textContent = `Session: $${validSessionCost.toFixed(4)}`;
      
      if (lastCost !== null) {
        const validLastCost = isNaN(lastCost) ? 0 : lastCost;
        els.lastCost.textContent = `Last: $${validLastCost.toFixed(4)}`;
      }
      
      if (tokens !== null) {
        const validTokens = isNaN(tokens) ? 0 : tokens;
        els.tokenCount.textContent = `Tokens: ${validTokens.toLocaleString()}`;
      }
      
      localStorage.setItem(LS.sessionCost, validSessionCost.toString());
    }

    function calculateCost(provider, model, inputTokens, outputTokens) {
      const validInput = isNaN(inputTokens) ? 0 : inputTokens;
      const validOutput = isNaN(outputTokens) ? 0 : outputTokens;
      
      const pricing = PRICING[provider]?.[model];
      if (!pricing) return 0;
      
      const inputCost = (validInput / 1000000) * pricing.input;
      const outputCost = (validOutput / 1000000) * pricing.output;
      const total = inputCost + outputCost;
      
      return isNaN(total) ? 0 : total;
    }

    function populateModels() {
      const provider = els.provider.value;
      const models = PROVIDER_MODELS[provider] || [];
      
      els.model.innerHTML = '';
      for (const m of models) {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        els.model.appendChild(opt);
      }

      const saved = localStorage.getItem(LS.model);
      if (saved && models.includes(saved)) {
        els.model.value = saved;
      }
    }

    function loadState() {
      const provider = localStorage.getItem(LS.provider) || 'openai';
      els.provider.value = provider;
      
      populateModels();

      const key = localStorage.getItem(LS.keys[provider]) || '';
      els.apiKey.value = key;
      
      const customModel = localStorage.getItem(LS.customModel) || '';
      els.customModel.value = customModel;

      els.keyHint.textContent = key ? maskKey(key) : '';
      els.modelHint.textContent = effectiveModel();
      els.providerHint.textContent = provider;

      const savedCost = localStorage.getItem(LS.sessionCost);
      const parsedCost = parseFloat(savedCost);
      sessionTotalCost = isNaN(parsedCost) ? 0 : parsedCost;
      updateCostDisplay();

      loadChats();
    }

    function saveState() {
      const provider = els.provider.value;
      localStorage.setItem(LS.provider, provider);
      localStorage.setItem(LS.keys[provider], els.apiKey.value.trim());
      localStorage.setItem(LS.model, els.model.value);
      localStorage.setItem(LS.customModel, els.customModel.value.trim());
      
      els.keyHint.textContent = els.apiKey.value.trim() ? maskKey(els.apiKey.value.trim()) : '';
      els.modelHint.textContent = effectiveModel();
      els.providerHint.textContent = provider;
    }

    function resetCost() {
      sessionTotalCost = 0;
      localStorage.setItem(LS.sessionCost, '0');
      updateCostDisplay(0, 0);
      addMessage('meta', 'Cost tracker reset to $0.00');
    }

    function effectiveModel() {
      return (els.customModel.value || '').trim() || els.model.value;
    }

    async function sendMessageFromHistory(messagesToSend, userText) {
      const provider = els.provider.value;
      const apiKey = els.apiKey.value.trim();
      const model = effectiveModel();

      if (!apiKey) {
        setStatus('missing api key', false);
        return;
      }
      if (!model) {
        setStatus('missing model', false);
        return;
      }

      els.send.disabled = true;
      els.send2.disabled = true;
      setStatus('thinking…', true);

      try {
        let response, usage;

        if (provider === 'openai') {
          const result = await sendOpenAI(apiKey, model, messagesToSend);
          response = result.content;
          usage = result.usage;
        } else if (provider === 'gemini') {
          const result = await sendGemini(apiKey, model, messagesToSend);
          response = result.content;
          usage = result.usage;
        }

        addMessage('assistant', response || '[empty response]');

        if (usage) {
          const inputTokens = usage.input || 0;
          const outputTokens = usage.output || 0;
          const cost = calculateCost(provider, model, inputTokens, outputTokens);
          
          sessionTotalCost += cost;
          const totalTokens = inputTokens + outputTokens;
          updateCostDisplay(cost, totalTokens);
          
          if (cost > 0 || totalTokens > 0) {
            addMessage('meta', `${inputTokens.toLocaleString()} in + ${outputTokens.toLocaleString()} out = ${totalTokens.toLocaleString()} tokens | $${cost.toFixed(4)}`);
          }
        }

        setStatus('done', true);
      } catch (e) {
        addMessage('assistant', `Error: ${e.message || String(e)}`);
        setStatus('error', false);
      } finally {
        els.send.disabled = false;
        els.send2.disabled = false;
      }
    }

    async function sendMessage(textOverride = null, skipAddUser = false) {
      const provider = els.provider.value;
      const apiKey = els.apiKey.value.trim();
      const text = textOverride || els.input.value.trim();
      const model = effectiveModel();

      if (!text) return;
      if (!apiKey) {
        setStatus('missing api key', false);
        return;
      }
      if (!model) {
        setStatus('missing model', false);
        return;
      }

      if (!skipAddUser) {
        addMessage('user', text);
        els.input.value = '';
      }

      els.send.disabled = true;
      els.send2.disabled = true;
      setStatus('thinking…', true);

      try {
        let response, usage;

        if (provider === 'openai') {
          const result = await sendOpenAI(apiKey, model, activeChat.messages);
          response = result.content;
          usage = result.usage;
        } else if (provider === 'gemini') {
          const result = await sendGemini(apiKey, model, activeChat.messages);
          response = result.content;
          usage = result.usage;
        }

        addMessage('assistant', response || '[empty response]');

        if (usage) {
          const inputTokens = usage.input || 0;
          const outputTokens = usage.output || 0;
          const cost = calculateCost(provider, model, inputTokens, outputTokens);
          
          sessionTotalCost += cost;
          const totalTokens = inputTokens + outputTokens;
          updateCostDisplay(cost, totalTokens);
          
          if (cost > 0 || totalTokens > 0) {
            addMessage('meta', `${inputTokens.toLocaleString()} in + ${outputTokens.toLocaleString()} out = ${totalTokens.toLocaleString()} tokens | $${cost.toFixed(4)}`);
          }
        }

        setStatus('done', true);
      } catch (e) {
        addMessage('assistant', `Error: ${e.message || String(e)}`);
        setStatus('error', false);
      } finally {
        els.send.disabled = false;
        els.send2.disabled = false;
      }
    }

    async function sendOpenAI(apiKey, model, messages) {
      const res = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({ model, messages })
      });

      const data = await res.json();
      if (!res.ok) {
        throw new Error((data?.error?.message) || `HTTP ${res.status}`);
      }

      return {
        content: data?.choices?.[0]?.message?.content ?? '',
        usage: {
          input: data?.usage?.prompt_tokens || 0,
          output: data?.usage?.completion_tokens || 0
        }
      };
    }

    async function sendGemini(apiKey, model, messages) {
      const systemMsg = messages.find(m => m.role === 'system');
      const chatMsgs = messages.filter(m => m.role !== 'system' && m.role !== 'meta');

      const contents = chatMsgs.map(m => ({
        role: m.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: m.content }]
      }));

      const body = {
        contents,
        generationConfig: { maxOutputTokens: 8192 }
      };

      if (systemMsg) {
        body.systemInstruction = {
          parts: [{ text: systemMsg.content }]
        };
      }

      const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      const data = await res.json();
      if (!res.ok) {
        throw new Error((data?.error?.message) || `HTTP ${res.status}`);
      }

      return {
        content: data?.candidates?.[0]?.content?.parts?.[0]?.text ?? '',
        usage: {
          input: data?.usageMetadata?.promptTokenCount || 0,
          output: data?.usageMetadata?.candidatesTokenCount || 0
        }
      };
    }

    // Event Listeners
    els.toggleSidebar.onclick = () => els.sidebar.classList.toggle('hidden');
    els.newChat.onclick = createNewChat;
    els.provider.addEventListener('change', () => {
      const provider = els.provider.value;
      const savedKey = localStorage.getItem(LS.keys[provider]) || '';
      els.apiKey.value = savedKey;
      populateModels();
      saveState();
    });

    els.apiKey.addEventListener('input', saveState);
    els.model.addEventListener('change', saveState);
    els.customModel.addEventListener('input', saveState);

    els.resetCost.addEventListener('click', resetCost);
    els.send.addEventListener('click', () => sendMessage());
    els.send2.addEventListener('click', () => sendMessage());

    els.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    loadState();
    setStatus('idle', true);
  </script>
</body>
</html>
