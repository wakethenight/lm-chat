<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multi-Provider LLM UI</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #151922;
      --panel2: #10131a;
      --text: #e7e9ee;
      --muted: #a7adbb;
      --border: #2a3142;
      --accent: #7d0fd6;
      --accent2: #4f7cff;
      --danger: #ff4d4d;
      --ok: #33d17a;
      --warning: #ffa500;
      --bubbleUser: #7d0fd6;
      --bubbleAI: #2a3142;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: radial-gradient(1200px 800px at 20% 0%, rgba(125,15,214,0.18), transparent 55%),
                  radial-gradient(900px 600px at 100% 10%, rgba(79,124,255,0.14), transparent 60%),
                  var(--bg);
      color: var(--text);
      font-family: var(--sans);
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(21,25,34,0.95), rgba(16,19,26,0.95));
      backdrop-filter: blur(8px);
    }

    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }

    .labelRow {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      min-width: 0;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .hint {
      font-size: 11px;
      color: var(--muted);
      opacity: 0.9;
      font-family: var(--mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    input[type="password"], input[type="text"], select {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(10,12,18,0.75);
      color: var(--text);
      outline: none;
    }

    input[type="password"]:focus, input[type="text"]:focus, select:focus, textarea:focus {
      border-color: rgba(125,15,214,0.65);
      box-shadow: 0 0 0 3px rgba(125,15,214,0.18);
    }

    .btnRow {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    button {
      border: 1px solid var(--border);
      background: rgba(10,12,18,0.7);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
    }

    button.primary {
      border-color: rgba(125,15,214,0.45);
      background: linear-gradient(135deg, rgba(125,15,214,0.95), rgba(79,124,255,0.75));
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #chat {
      flex: 1;
      overflow-y: auto;
      padding: 16px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .msg {
      max-width: 78ch;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.06);
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .msg.user {
      align-self: flex-end;
      background: rgba(125,15,214,0.9);
      border-color: rgba(125,15,214,0.25);
      border-bottom-right-radius: 6px;
    }

    .msg.assistant {
      align-self: flex-start;
      background: rgba(42,49,66,0.65);
      border-color: rgba(42,49,66,0.85);
      border-bottom-left-radius: 6px;
    }

    .msg.meta {
      align-self: center;
      max-width: 100%;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      background: rgba(10,12,18,0.45);
      border-color: rgba(255,255,255,0.06);
    }

    .composer {
      border-top: 1px solid var(--border);
      padding: 12px;
      background: linear-gradient(0deg, rgba(21,25,34,0.95), rgba(16,19,26,0.95));
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
    }

    textarea {
      width: 100%;
      min-height: 54px;
      max-height: 220px;
      resize: vertical;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(10,12,18,0.75);
      color: var(--text);
      outline: none;
      font-family: var(--sans);
    }

    .status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-top: 1px dashed rgba(255,255,255,0.08);
      background: rgba(10,12,18,0.35);
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      flex-wrap: wrap;
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pill.ok { border-color: rgba(51,209,122,0.25); color: var(--ok); }
    .pill.bad { border-color: rgba(255,77,77,0.25); color: var(--danger); }
    .pill.warn { border-color: rgba(255,165,0,0.25); color: var(--warning); }

    .costTracker {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    @media (max-width: 768px) {
      .row { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <div class="field">
        <div class="labelRow">
          <label>Provider</label>
          <span class="hint" id="providerHint"></span>
        </div>
        <select id="provider">
          <option value="openai">OpenAI</option>
          <option value="gemini">Google (Gemini)</option>
        </select>
      </div>

      <div class="field">
        <div class="labelRow">
          <label for="apiKey">API Key</label>
          <span class="hint" id="keyHint"></span>
        </div>
        <input id="apiKey" type="password" placeholder="Paste your key here..." autocomplete="off" />
      </div>

      <div class="field">
        <div class="labelRow">
          <label for="model">Model</label>
          <span class="hint" id="modelHint"></span>
        </div>
        <select id="model">
          <!-- Populated dynamically based on provider -->
        </select>
      </div>

      <div class="field">
        <div class="labelRow">
          <label for="customModel">Custom model</label>
          <span class="hint">optional override</span>
        </div>
        <input id="customModel" type="text" placeholder="e.g. gpt-4.1 or fine-tune" />
      </div>
    </div>

    <div class="btnRow">
      <button id="resetCost">Reset Cost</button>
      <button id="clearChat">Clear Chat</button>
      <button id="send" class="primary">Send</button>
    </div>
  </header>

  <main>
    <div id="chat">
      <div class="msg assistant">Welcome! Select your provider, paste your API key, pick a model, and start chatting. Cost tracking is enabled.</div>
      <div class="msg meta">Your keys are stored locally in your browser. Token usage and costs are calculated in real-time.</div>
    </div>

    <div class="composer">
      <textarea id="input" placeholder="Type here. Enter = send, Shift+Enter = newline."></textarea>
      <button id="send2" class="primary">Send</button>
    </div>

    <div class="status">
      <div class="pill" id="statusLeft">idle</div>
      <div class="costTracker">
        <div class="pill warn" id="sessionCost">Session: $0.00</div>
        <div class="pill" id="lastCost">Last: $0.00</div>
        <div class="pill" id="tokenCount">Tokens: 0</div>
      </div>
    </div>
  </main>

  <script>
    // Pricing per 1M tokens (as of early 2025, adjust as needed)
    const PRICING = {
      openai: {
        'gpt-4.1': { input: 15.00, output: 60.00 },
        'gpt-4.1-mini': { input: 1.50, output: 6.00 },
        'gpt-4.1-nano': { input: 0.40, output: 1.60 },
        'gpt-4o': { input: 2.50, output: 10.00 },
        'gpt-4o-mini': { input: 0.15, output: 0.60 },
        'o1': { input: 15.00, output: 60.00 },
        'o1-mini': { input: 3.00, output: 12.00 },
        'o3-mini': { input: 1.10, output: 4.40 }
      },
      gemini: {
      	'gemini-3-pro-preview': [2.00, 12.00],
	'gemini-2.5-pro': [1.25, 10.00], 
	'gemini-2.5-flash': [0.30, 2.50],
        'gemini-2.0-flash-exp': [0.00, 0.00], // Free during preview
        'gemini-exp-1206': [0.00, 0.00],
        'gemini-2.0-flash-thinking-exp-1219': [0.00, 0.00],
        'gemini-1.5-pro': [1.25, 5.00],
        'gemini-1.5-flash': [0.075, 0.30],
        'gemini-1.5-flash-8b': [0.0375, 0.15]
      }
    };

    const PROVIDER_MODELS = {
      openai: [
        'gpt-4.1',
        'gpt-4.1-mini',
        'gpt-4.1-nano',
        'gpt-4o',
        'gpt-4o-mini',
        'o1',
        'o1-mini',
        'o3-mini'
      ],
      gemini: [
     	'gemini-3-pro-preview',
	'gemini-2.5-pro',
	'gemini-2.5-flash',
        'gemini-2.0-flash-exp',
        'gemini-exp-1206',
        'gemini-2.0-flash-thinking-exp-1219',
        'gemini-1.5-pro',
        'gemini-1.5-flash',
        'gemini-1.5-flash-8b'
      ]
    };

    const els = {
      provider: document.getElementById('provider'),
      apiKey: document.getElementById('apiKey'),
      model: document.getElementById('model'),
      customModel: document.getElementById('customModel'),
      resetCost: document.getElementById('resetCost'),
      clearChat: document.getElementById('clearChat'),
      send: document.getElementById('send'),
      send2: document.getElementById('send2'),
      input: document.getElementById('input'),
      chat: document.getElementById('chat'),
      statusLeft: document.getElementById('statusLeft'),
      keyHint: document.getElementById('keyHint'),
      modelHint: document.getElementById('modelHint'),
      providerHint: document.getElementById('providerHint'),
      sessionCost: document.getElementById('sessionCost'),
      lastCost: document.getElementById('lastCost'),
      tokenCount: document.getElementById('tokenCount')
    };

    const LS = {
      provider: 'llmui_provider',
      keys: {
        openai: 'llmui_openai_key',
        gemini: 'llmui_gemini_key'
      },
      model: 'llmui_model_v2',
      customModel: 'llmui_custom_model',
      messages: 'llmui_messages_v2',
      sessionCost: 'llmui_session_cost'
    };

    let sessionTotalCost = parseFloat(localStorage.getItem(LS.sessionCost) || '0');

    function maskKey(k) {
      if (!k) return '';
      if (k.length <= 10) return 'key set';
      return `${k.slice(0, 3)}…${k.slice(-4)}`;
    }

    function setStatus(left, ok = true) {
      els.statusLeft.textContent = left || '';
      els.statusLeft.className = `pill ${ok ? 'ok' : 'bad'}`;
    }

    function updateCostDisplay(lastCost = null, tokens = null) {
      els.sessionCost.textContent = `Session: $${sessionTotalCost.toFixed(4)}`;
      if (lastCost !== null) {
        els.lastCost.textContent = `Last: $${lastCost.toFixed(4)}`;
      }
      if (tokens !== null) {
        els.tokenCount.textContent = `Tokens: ${tokens.toLocaleString()}`;
      }
      localStorage.setItem(LS.sessionCost, sessionTotalCost.toString());
    }

    function calculateCost(provider, model, inputTokens, outputTokens) {
      const pricing = PRICING[provider]?.[model];
      if (!pricing) return 0;
      
      const inputCost = (inputTokens / 1000000) * pricing.input;
      const outputCost = (outputTokens / 1000000) * pricing.output;
      return inputCost + outputCost;
    }

    function addMsg(role, text) {
      const div = document.createElement('div');
      div.className = `msg ${role}`;
      div.textContent = text;
      els.chat.appendChild(div);
      els.chat.scrollTop = els.chat.scrollHeight;
    }

    function populateModels() {
      const provider = els.provider.value;
      const models = PROVIDER_MODELS[provider] || [];
      
      els.model.innerHTML = '';
      for (const m of models) {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        els.model.appendChild(opt);
      }

      const saved = localStorage.getItem(LS.model);
      if (saved && models.includes(saved)) {
        els.model.value = saved;
      }
    }

    function loadState() {
      const provider = localStorage.getItem(LS.provider) || 'openai';
      els.provider.value = provider;
      
      populateModels();

      const key = localStorage.getItem(LS.keys[provider]) || '';
      els.apiKey.value = key;
      
      const customModel = localStorage.getItem(LS.customModel) || '';
      els.customModel.value = customModel;

      els.keyHint.textContent = key ? maskKey(key) : '';
      els.modelHint.textContent = effectiveModel();
      els.providerHint.textContent = provider;

      updateCostDisplay();

      const saved = localStorage.getItem(LS.messages);
      if (saved) {
        try {
          const data = JSON.parse(saved);
          if (data.provider === provider && Array.isArray(data.messages) && data.messages.length) {
            addMsg('meta', 'restored previous session');
            for (const m of data.messages) {
              if (!m || typeof m !== 'object') continue;
              if (m.role === 'user') addMsg('user', m.content || '');
              if (m.role === 'assistant') addMsg('assistant', m.content || '');
            }
          }
        } catch {}
      }
    }

    function saveState() {
      const provider = els.provider.value;
      localStorage.setItem(LS.provider, provider);
      localStorage.setItem(LS.keys[provider], els.apiKey.value.trim());
      localStorage.setItem(LS.model, els.model.value);
      localStorage.setItem(LS.customModel, els.customModel.value.trim());
      
      els.keyHint.textContent = els.apiKey.value.trim() ? maskKey(els.apiKey.value.trim()) : '';
      els.modelHint.textContent = effectiveModel();
      els.providerHint.textContent = provider;
    }

    function clearChat() {
      els.chat.innerHTML = '';
      addMsg('assistant', 'Chat cleared. Ready when you are.');
      localStorage.removeItem(LS.messages);
      messages = [{ role: 'system', content: 'You are a helpful assistant.' }];
      setStatus('idle', true);
    }

    function resetCost() {
      sessionTotalCost = 0;
      updateCostDisplay(0, 0);
      addMsg('meta', 'Cost tracker reset to $0.00');
    }

    function effectiveModel() {
      return (els.customModel.value || '').trim() || els.model.value;
    }

    let messages = [{ role: 'system', content: 'You are a helpful assistant.' }];

    function persistMessages() {
      const provider = els.provider.value;
      const toSave = messages.filter(m => m.role === 'user' || m.role === 'assistant');
      localStorage.setItem(LS.messages, JSON.stringify({ provider, messages: toSave }));
    }

    async function sendMessage() {
      const provider = els.provider.value;
      const apiKey = els.apiKey.value.trim();
      const text = els.input.value.trim();
      const model = effectiveModel();

      if (!text) return;
      if (!apiKey) {
        setStatus('missing api key', false);
        return;
      }
      if (!model) {
        setStatus('missing model', false);
        return;
      }

      addMsg('user', text);
      messages.push({ role: 'user', content: text });
      persistMessages();

      els.input.value = '';
      els.send.disabled = true;
      els.send2.disabled = true;
      setStatus('thinking…', true);

      try {
        let response, usage;

        if (provider === 'openai') {
          const result = await sendOpenAI(apiKey, model, messages);
          response = result.content;
          usage = result.usage;
        } else if (provider === 'gemini') {
          const result = await sendGemini(apiKey, model, messages);
          response = result.content;
          usage = result.usage;
        }

        addMsg('assistant', response || '[empty response]');
        messages.push({ role: 'assistant', content: response || '' });
        persistMessages();

        // Calculate and update cost
        if (usage) {
          const cost = calculateCost(provider, model, usage.input, usage.output);
          sessionTotalCost += cost;
          const totalTokens = usage.input + usage.output;
          updateCostDisplay(cost, totalTokens);
          
          addMsg('meta', `${usage.input.toLocaleString()} in + ${usage.output.toLocaleString()} out = ${totalTokens.toLocaleString()} tokens | $${cost.toFixed(4)}`);
        }

        setStatus('done', true);
      } catch (e) {
        addMsg('assistant', `Error: ${e.message || String(e)}`);
        setStatus('error', false);
      } finally {
        els.send.disabled = false;
        els.send2.disabled = false;
      }
    }

    async function sendOpenAI(apiKey, model, messages) {
      const res = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({ model, messages })
      });

      const data = await res.json();
      if (!res.ok) {
        throw new Error((data?.error?.message) || `HTTP ${res.status}`);
      }

      return {
        content: data?.choices?.[0]?.message?.content ?? '',
        usage: {
          input: data?.usage?.prompt_tokens || 0,
          output: data?.usage?.completion_tokens || 0
        }
      };
    }

    async function sendGemini(apiKey, model, messages) {
      const systemMsg = messages.find(m => m.role === 'system');
      const chatMsgs = messages.filter(m => m.role !== 'system');

      const contents = chatMsgs.map(m => ({
        role: m.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: m.content }]
      }));

      const body = {
        contents,
        generationConfig: { maxOutputTokens: 8192 }
      };

      if (systemMsg) {
        body.systemInstruction = {
          parts: [{ text: systemMsg.content }]
        };
      }

      const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      const data = await res.json();
      if (!res.ok) {
        throw new Error((data?.error?.message) || `HTTP ${res.status}`);
      }

      return {
        content: data?.candidates?.[0]?.content?.parts?.[0]?.text ?? '',
        usage: {
          input: data?.usageMetadata?.promptTokenCount || 0,
          output: data?.usageMetadata?.candidatesTokenCount || 0
        }
      };
    }

    els.provider.addEventListener('change', () => {
      const provider = els.provider.value;
      const savedKey = localStorage.getItem(LS.keys[provider]) || '';
      els.apiKey.value = savedKey;
      populateModels();
      saveState();
      
      messages = [{ role: 'system', content: 'You are a helpful assistant.' }];
      localStorage.removeItem(LS.messages);
    });

    els.apiKey.addEventListener('input', saveState);
    els.model.addEventListener('change', saveState);
    els.customModel.addEventListener('input', saveState);

    els.resetCost.addEventListener('click', resetCost);
    els.clearChat.addEventListener('click', clearChat);
    els.send.addEventListener('click', sendMessage);
    els.send2.addEventListener('click', sendMessage);

    els.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    loadState();
    setStatus('idle', true);
  </script>
</body>
</html>
